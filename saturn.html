<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Saturn Ring Defense</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(45deg, #000011, #000033, #001122);
            color: white;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #gameCanvas {
            border: 2px solid #444;
            background: radial-gradient(circle, #001133 0%, #000011 100%);
        }
        
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #444;
        }
        
        #defensePanel {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: row;
            gap: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #444;
        }
        
        .defenseGroup {
            display: flex;
            flex-direction: column;
            gap: 2px;
            align-items: center;
        }
        
        .defenseRow {
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }
        
        .defenseButton {
            padding: 10px 15px;
            background: linear-gradient(45deg, #333, #555);
            border: 2px solid #666;
            color: white;
            cursor: pointer;
            border-radius: 5px;
            text-align: center;
            font-size: 12px;
            transition: all 0.3s;
        }
        
        .defenseButton:hover {
            background: linear-gradient(45deg, #555, #777);
            border-color: #888;
        }
        
        .defenseButton.selected {
            background: linear-gradient(45deg, #004488, #0066bb);
            border-color: #0088ff;
        }
        
        .defenseButton.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .upgradeButton {
            padding: 5px 10px;
            background: linear-gradient(45deg, #224466, #446688);
            border: 1px solid #6688aa;
            color: white;
            cursor: pointer;
            border-radius: 3px;
            font-size: 10px;
            transition: all 0.3s;
            text-align: center;
            margin-top: 2px;
            height: 40px;
            line-height: 10px;
            width: 100%; /* Match defender button width */
            box-sizing: border-box;
        }
        
        .upgradeButton:hover {
            background: linear-gradient(45deg, #446688, #6688aa);
            border-color: #88aacc;
        }
        
        .upgradeButton.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        #waveInfo {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #444;
            text-align: center;
        }
        
        .health-bar {
            width: 30px;
            height: 4px;
            background: #333;
            margin-top: 2px;
        }
        
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff4444, #ffaa44, #44ff44);
            transition: width 0.3s;
        }
        
        #controlPanel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #444;
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 150px;
        }
        
        /* Mobile responsive styles */
        @media (max-width: 768px) {
            #ui {
                top: 10px;
                left: 10px;
                padding: 10px;
                font-size: 12px;
                border-radius: 8px;
            }
            
            #ui div {
                margin-bottom: 3px;
            }
            
            #controlPanel {
                top: 10px;
                right: 10px;
                padding: 10px;
                min-width: 120px;
                border-radius: 8px;
                gap: 8px;
                flex-direction: row; /* Horizontal layout on mobile */
                flex-wrap: wrap; /* Allow wrapping if needed */
                max-width: 300px; /* Limit width */
            }
            
            #controlPanel > div {
                font-size: 11px;
                padding: 8px;
                flex: 1; /* Equal width buttons */
                min-width: 80px; /* Minimum button width */
            }
            
            #bossWarning {
                font-size: 10px !important;
                padding: 8px !important;
                margin-top: 8px !important;
            }
            
            /* Mobile game area scaling */
            #gameCanvas {
                transform: scale(0.85);
                transform-origin: center center;
            }
        }
        
        @media (max-width: 480px) {
            #ui {
                top: 5px;
                left: 5px;
                padding: 8px;
                font-size: 10px;
                border-radius: 6px;
            }
            
            #ui div {
                margin-bottom: 2px;
            }
            
            #controlPanel {
                top: 5px;
                right: 5px;
                padding: 8px;
                min-width: 100px;
                border-radius: 6px;
                gap: 6px;
                flex-direction: row; /* Horizontal layout on mobile */
                flex-wrap: wrap; /* Allow wrapping if needed */
                max-width: 250px; /* Limit width */
            }
            
            #controlPanel > div {
                font-size: 10px;
                padding: 6px;
                flex: 1; /* Equal width buttons */
                min-width: 60px; /* Minimum button width */
            }
            
            #bossWarning {
                font-size: 9px !important;
                padding: 6px !important;
                margin-top: 6px !important;
            }
            
            /* Mobile game area scaling - more zoom out for smaller screens */
            #gameCanvas {
                transform: scale(0.75);
                transform-origin: center center;
            }
        }
        
        /* Extra small mobile devices */
        @media (max-width: 360px) {
            #gameCanvas {
                transform: scale(0.65);
                transform-origin: center center;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="800"></canvas>
        
        <div id="ui">
            <div>Money: $<span id="money">100</span></div>
            <div>Lives: <span id="lives">20</span></div>
            <div>Score: <span id="score">0</span></div>
            <div>Wave: <span id="wave">1</span></div>
            <div>Enemies: <span id="enemiesLeft">0</span></div>
            <div>Kills: <span id="totalKills">0</span> (×<span id="killMultiplier">1.0</span>)</div>
            <div>Defenders: <span id="totalDefenders">0</span> (+<span id="defenderBonus">0</span>%)</div>
            <div id="nextWaveTimer"></div>
            <div id="bossWarning" style="margin-top: 10px; padding: 10px; background: #660000; border: 2px solid #880000; border-radius: 5px; text-align: center; display: none; color: #ff0000; font-weight: bold;">
                ⚠️ RING BOSS INCOMING! ⚠️
            </div>
        </div>
        
        <div id="controlPanel">
            <div style="text-align: center; font-weight: bold; margin-bottom: 5px;">Controls</div>
            <div id="startButton" style="padding: 10px; background: #006600; border: 2px solid #008800; border-radius: 5px; cursor: pointer; text-align: center; color: white;">
                START GAME
            </div>
            <div id="pauseButton" style="padding: 10px; background: #666600; border: 2px solid #888800; border-radius: 5px; cursor: pointer; text-align: center; color: white; display: none;">
                PAUSE
            </div>
            <div id="deleteButton" style="padding: 10px; background: #660000; border: 2px solid #880000; border-radius: 5px; cursor: pointer; text-align: center; color: white;">
                Delete Defender<br>50% Refund
            </div>
            <div id="unlockRingButton" style="padding: 10px; background: #660066; border: 2px solid #880088; border-radius: 5px; cursor: pointer; text-align: center; color: white;">
                Unlock Ring<br>$500
            </div>
            <div style="text-align: center; font-size: 12px; margin-top: 5px;">Rings: <span id="unlockedRings">1</span>/4</div>
        </div>
        
        <div id="defensePanel">
            <div class="defenseRow">
                <div class="defenseGroup">
                    <div class="defenseButton" data-type="laser" data-cost="25">
                        Laser Tower<br>$25
                    </div>
                    <div class="upgradeButton" data-type="laser" data-cost="100">
                        Upgrade $100
                    </div>
                </div>
                <div class="defenseGroup">
                    <div class="defenseButton" data-type="missile" data-cost="50">
                        Missile Tower<br>$50
                    </div>
                    <div class="upgradeButton" data-type="missile" data-cost="100">
                        Upgrade $100
                    </div>
                </div>
                <div class="defenseGroup">
                    <div class="defenseButton" data-type="plasma" data-cost="75">
                        Plasma Tower<br>$75
                    </div>
                    <div class="upgradeButton" data-type="plasma" data-cost="100">
                        Upgrade $100
                    </div>
                </div>
                <div class="defenseGroup">
                    <div class="defenseButton" data-type="shield" data-cost="100">
                        Shield Tower<br>$100
                    </div>
                    <div class="upgradeButton" data-type="shield" data-cost="100">
                        Upgrade $100
                    </div>
                </div>
            </div>
        </div>
        
        <div id="pauseMenu" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.9); padding: 30px; border: 3px solid #666; border-radius: 15px; text-align: center; display: none; z-index: 200;">
            <h2 style="color: white; margin-top: 0;">GAME PAUSED</h2>
            <div id="resumeButton" style="margin: 10px; padding: 15px 25px; background: #006600; border: 2px solid #008800; border-radius: 5px; cursor: pointer; color: white; display: inline-block;">
                RESUME
            </div>
            <div id="restartButton" style="margin: 10px; padding: 15px 25px; background: #660000; border: 2px solid #880000; border-radius: 5px; cursor: pointer; color: white; display: inline-block;">
                RESTART
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game state
        let gameState = {
            money: 100,
            lives: 20,
            score: 0,
            wave: 1,
            selectedDefenseType: null,
            unlockedRings: 1,
            deleteMode: false,
            defenders: [],
            enemies: [],
            projectiles: [],
            particles: [],
            stars: [], // Add stars array
            lastUpdate: 0,
            waveActive: false,
            enemiesSpawned: 0,
            enemiesKilled: 0,
            totalEnemiesKilled: 0,
            totalDefendersPlaced: 0,
            waveStartTime: 0,
            nextWaveDelay: 3000,
            gameStarted: false,
            gameRunning: false,
            gamePaused: false,
            gameOver: false, // Add game over state
            killMultiplier: 1,
            defenderBonus: 1,
            ringBossWaves: 0, // Track how many times ring boss has appeared
            defenderUpgrades: { laser: 0, missile: 0, plasma: 0, shield: 0 }, // Track upgrade levels
            gunActive: false, // Track if gun is active
            gunCooldown: 0, // Track gun cooldown
            mouseX: canvas.width / 2, // Track mouse position
            mouseY: canvas.height / 2, // Track mouse position
            gunAngle: 0, // Track gun rotation angle
            targetGunAngle: 0, // Target angle for smooth rotation
            barrelExtension: 0, // Track barrel slide animation (0-1)
            pauseStartTime: 0 // Track when pause started
        };
        
        // Saturn properties
        const saturn = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            radius: 80,
            rings: [
                { inner: 100, outer: 120, color: 'rgba(255, 200, 200, 0.4)' },  // Ring 1 - reddish
                { inner: 140, outer: 160, color: 'rgba(200, 255, 200, 0.4)' },  // Ring 2 - greenish
                { inner: 180, outer: 200, color: 'rgba(200, 200, 255, 0.4)' },  // Ring 3 - bluish
                { inner: 220, outer: 240, color: 'rgba(255, 255, 200, 0.4)' }   // Ring 4 - yellowish
            ]
        };
        
        // Gun configuration - easy to modify
        const gunConfig = {
            damage: 100,           // Damage per shot
            cost: 25,              // Cost per shot
            cooldown: 500,         // Cooldown between shots (ms)
            range: 800,            // Range of the laser
            width: 10,              // Width of the laser beam
            color: '#ff0066',      // Color of the laser
            aimRingRadius: 15,     // Radius of the aiming ring
            aimRingColor: '#ff0066', // Color of the aiming ring
            gunSize: 15,           // Size of the gun on Saturn
            barrelLength: 50,      // Length of the cannon barrel
            barrelWidth: 18,        // Width of the cannon barrel
            baseSize: 22,          // Size of the cannon base
            rotationSpeed: 0.1     // How fast the cannon rotates (0-1)
        };
        
        // Defense types
        const defenseTypes = {
            laser: {
                cost: 25,
                health: 100,
                damage: 15,
                range: 120,
                fireRate: 800,
                color: '#ff4444',
                projectileSpeed: 8,
                size: 8
            },
            missile: {
                cost: 50,
                health: 120,
                damage: 30,
                range: 150,
                fireRate: 1200,
                color: '#44ff44',
                projectileSpeed: 5,
                size: 10,
                explosive: true
            },
            plasma: {
                cost: 75,
                health: 150,
                damage: 25,
                range: 100,
                fireRate: 600,
                color: '#4444ff',
                projectileSpeed: 6,
                size: 12,
                piercing: true
            },
            shield: {
                cost: 100,
                health: 300,
                damage: 0,
                range: 60,
                fireRate: 0,
                color: '#ffff44',
                projectileSpeed: 0,
                size: 15,
                blocking: true
            }
        };
        
        // Enemy types
        const enemyTypes = {
            basic: {
                health: 50,
                speed: 1,
                reward: 10,
                color: '#ff6666',
                size: 8
            },
            fast: {
                health: 30,
                speed: 2,
                reward: 15,
                color: '#66ff66',
                size: 6
            },
            heavy: {
                health: 150,
                speed: 0.5,
                reward: 30,
                color: '#6666ff',
                size: 12
            },
            jetpack: {
                health: 180, // Increased from 120 to 180
                speed: 0.5, // Reduced from 0.8 to 0.5
                reward: 25,
                color: '#ffaa44',
                size: 10,
                isJetpack: true
            },
            boss: {
                health: 500,
                speed: 0.3,
                reward: 100,
                color: '#ff66ff',
                size: 20
            },
            ringBoss: {
                health: 5000,
                speed: 0.2,
                reward: 500,
                color: '#ff0000',
                size: 25,
                isRingBoss: true
            }
        };
        
        class Defender {
            constructor(angle, type, ring) {
                this.angle = angle;
                this.type = type;
                this.ring = ring;
                this.props = defenseTypes[type];
                this.health = this.props.health;
                this.maxHealth = this.props.health;
                this.lastFire = 0;
                this.orbitRadius = saturn.rings[ring].inner + (saturn.rings[ring].outer - saturn.rings[ring].inner) / 2;
                this.angularSpeed = 0.5; // degrees per frame
            }
            
            update(deltaTime) {
                // Orbit around Saturn
                this.angle += this.angularSpeed * deltaTime / 16;
                if (this.angle >= 360) this.angle -= 360;
                
                // Calculate position
                const rad = this.angle * Math.PI / 180;
                this.x = saturn.x + Math.cos(rad) * this.orbitRadius;
                this.y = saturn.y + Math.sin(rad) * this.orbitRadius;
                
                // Shield towers block instead of attacking
                if (this.type === 'shield') {
                    this.blockEnemies();
                } else {
                    // Find target and attack
                    const target = this.findTarget();
                    if (target && Date.now() - this.lastFire > this.props.fireRate) {
                        this.fire(target);
                        this.lastFire = Date.now();
                    }
                }
            }
            
            blockEnemies() {
                // Shield towers physically block enemies
                for (const enemy of gameState.enemies) {
                    const dist = Math.sqrt((enemy.x - this.x) ** 2 + (enemy.y - this.y) ** 2);
                    if (dist < this.props.size + enemy.props.size + 5) {
                        // Push enemy away from shield
                        const dx = enemy.x - this.x;
                        const dy = enemy.y - this.y;
                        const pushDist = this.props.size + enemy.props.size + 5;
                        const currentDist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (currentDist > 0) {
                            enemy.x = this.x + (dx / currentDist) * pushDist;
                            enemy.y = this.y + (dy / currentDist) * pushDist;
                        }
                        
                        // Slow down the enemy significantly
                        enemy.slow = Math.min(enemy.slow, 0.1);
                    }
                }
            }
            
            findTarget() {
                let closest = null;
                let closestDist = this.props.range;
                
                for (const enemy of gameState.enemies) {
                    const dist = Math.sqrt((enemy.x - this.x) ** 2 + (enemy.y - this.y) ** 2);
                    if (dist < closestDist) {
                        closest = enemy;
                        closestDist = dist;
                    }
                }
                
                return closest;
            }
            
            fire(target) {
                // Apply defender bonus and upgrade bonus to damage
                const upgradeBonus = Math.pow(1.02, gameState.defenderUpgrades[this.type]);
                const bonusDamage = this.props.damage * (1 + gameState.defenderBonus / 100) * upgradeBonus;
                
                const projectile = {
                    x: this.x,
                    y: this.y,
                    targetX: target.x,
                    targetY: target.y,
                    target: target,
                    damage: bonusDamage,
                    speed: this.props.projectileSpeed,
                    color: this.props.color,
                    type: this.type,
                    life: 1000
                };
                
                // Calculate velocity
                const dx = target.x - this.x;
                const dy = target.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                projectile.vx = (dx / dist) * projectile.speed;
                projectile.vy = (dy / dist) * projectile.speed;
                
                gameState.projectiles.push(projectile);
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // Draw defender with special effects for shield
                if (this.type === 'shield') {
                    // Draw shield with pulsing effect
                    const pulse = Math.sin(Date.now() * 0.005) * 0.3 + 0.7;
                    ctx.fillStyle = this.props.color;
                    ctx.globalAlpha = pulse;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.props.size * 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                    
                    // Draw shield core
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.props.size * 0.6, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Normal defender
                    ctx.fillStyle = this.props.color;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.props.size, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Draw health bar
                if (this.health < this.maxHealth) {
                    const barWidth = this.props.size * 2;
                    const barHeight = 3;
                    const healthPercent = this.health / this.maxHealth;
                    
                    ctx.fillStyle = '#333';
                    ctx.fillRect(-barWidth/2, -this.props.size - 8, barWidth, barHeight);
                    
                    ctx.fillStyle = healthPercent > 0.5 ? '#44ff44' : healthPercent > 0.25 ? '#ffff44' : '#ff4444';
                    ctx.fillRect(-barWidth/2, -this.props.size - 8, barWidth * healthPercent, barHeight);
                }
                
                ctx.restore();
            }
        }
        
        class Enemy {
            constructor(type) {
                this.type = type;
                this.props = enemyTypes[type];
                
                // Apply health scaling: enemies get 10% more health each wave
                const healthScaling = Math.pow(1.1, gameState.wave - 1);
                this.health = Math.floor(this.props.health * healthScaling);
                this.maxHealth = this.health;
                
                this.speed = this.props.speed;
                this.reward = this.props.reward;
                this.slow = 1;
                
                if (this.props.isRingBoss) {
                    // Ring boss starts at outer edge and orbits
                    this.orbitRadius = 500; // Much farther start
                    this.orbitAngle = Math.random() * 360;
                    this.orbitSpeed = 0.1; // Much slower orbit
                    this.spiralInward = 0.1; // Much slower inward movement
                    
                    // Scale ring boss based on how many times it has appeared
                    const bossScaling = 1 + (gameState.ringBossWaves * 0.5); // 50% increase each time
                    this.health = Math.floor(this.props.health * bossScaling);
                    this.maxHealth = this.health;
                    this.orbitSpeed *= (1 + gameState.ringBossWaves * 0.2); // 20% speed increase each time
                    this.spiralInward *= (1 + gameState.ringBossWaves * 0.3); // 30% faster inward movement
                    
                    this.x = saturn.x + Math.cos(this.orbitAngle * Math.PI / 180) * this.orbitRadius;
                    this.y = saturn.y + Math.sin(this.orbitAngle * Math.PI / 180) * this.orbitRadius;
                } else if (this.props.isJetpack) {
                    // Jetpack enemy starts from above and swoops in U-shape
                    this.x = Math.random() * canvas.width;
                    this.y = -50;
                    this.swoopPhase = 0; // 0 = diving down, 1 = swooping across, 2 = diving up
                    this.swoopStartX = this.x;
                    this.swoopStartY = this.y;
                    this.swoopTargetX = saturn.x + (Math.random() - 0.5) * 200; // Random target near Saturn
                    this.swoopTargetY = saturn.y + (Math.random() - 0.5) * 200;
                    this.swoopLowestY = Math.max(this.swoopTargetY + 100, saturn.y + 150); // Lowest point of swoop
                    this.swoopProgress = 0;
                    this.lastDefenderKill = 0; // Track when last defender was killed
                } else {
                    // Spawn at random edge
                    const edge = Math.floor(Math.random() * 4);
                    const margin = 50;
                    
                    switch(edge) {
                        case 0: // top
                            this.x = Math.random() * canvas.width;
                            this.y = -margin;
                            break;
                        case 1: // right
                            this.x = canvas.width + margin;
                            this.y = Math.random() * canvas.height;
                            break;
                        case 2: // bottom
                            this.x = Math.random() * canvas.width;
                            this.y = canvas.height + margin;
                            break;
                        case 3: // left
                            this.x = -margin;
                            this.y = Math.random() * canvas.height;
                            break;
                    }
                }
            }
            
            update(deltaTime) {
                if (this.props.isRingBoss) {
                    // Ring boss orbits and spirals inward
                    this.orbitAngle += this.orbitSpeed * deltaTime / 16;
                    this.orbitRadius -= this.spiralInward * deltaTime / 16;
                    
                    // Calculate new position
                    const rad = this.orbitAngle * Math.PI / 180;
                    this.x = saturn.x + Math.cos(rad) * this.orbitRadius;
                    this.y = saturn.y + Math.sin(rad) * this.orbitRadius;
                    
                    // Check for ring destruction
                    this.checkRingDestruction();
                    
                    // Check if reached Saturn center
                    if (this.orbitRadius <= saturn.radius) {
                        gameState.lives = 0; // Game over
                        return false;
                    }
                } else if (this.props.isJetpack) {
                    // Jetpack enemy swooping behavior
                    this.swoopProgress += this.speed * deltaTime / 16 * 0.02;
                    
                    if (this.swoopProgress <= 1) {
                        // Phase 1: Dive down to lowest point
                        const t = this.swoopProgress;
                        this.x = this.swoopStartX + (this.swoopTargetX - this.swoopStartX) * t;
                        this.y = this.swoopStartY + (this.swoopLowestY - this.swoopStartY) * (1 - Math.cos(t * Math.PI)) / 2;
                    } else if (this.swoopProgress <= 2) {
                        // Phase 2: Swoop across and up
                        const t = this.swoopProgress - 1;
                        this.x = this.swoopTargetX + (this.swoopStartX - this.swoopTargetX) * t;
                        this.y = this.swoopLowestY + (this.swoopStartY - this.swoopLowestY) * (1 - Math.cos(t * Math.PI)) / 2;
                    } else {
                        // Phase 3: Exit screen
                        this.y -= this.speed * deltaTime / 16 * 2;
                        if (this.y < -100) {
                            return false; // Remove enemy
                        }
                    }
                    
                    // Check for defender kills during swoop
                    if (Date.now() - this.lastDefenderKill > 500) { // Kill defenders every 500ms
                        this.killDefendersInPath();
                        this.lastDefenderKill = Date.now();
                    }
                    
                } else {
                    // Normal enemy behavior
                    const dx = saturn.x - this.x;
                    const dy = saturn.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < saturn.radius) {
                        // Reached Saturn!
                        gameState.lives--;
                        return false;
                    }
                    
                    const moveSpeed = this.speed * this.slow * deltaTime / 16;
                    this.x += (dx / dist) * moveSpeed;
                    this.y += (dy / dist) * moveSpeed;
                    
                    // Reset slow effect
                    this.slow = Math.min(1, this.slow + 0.02);
                }
                
                return true;
            }
            
            killDefendersInPath() {
                // Kill defenders that are close to the jetpack enemy's path
                for (let i = gameState.defenders.length - 1; i >= 0; i--) {
                    const defender = gameState.defenders[i];
                    const dist = Math.sqrt((defender.x - this.x) ** 2 + (defender.y - this.y) ** 2);
                    
                    if (dist < this.props.size + defender.props.size + 10) {
                        // Kill the defender
                        gameState.defenders.splice(i, 1);
                        gameState.totalDefendersPlaced--;
                        updateMultipliers();
                        
                        // Create explosion effect
                        createExplosion(defender.x, defender.y, defender.props.color);
                        
                        console.log('Defender killed by jetpack enemy!');
                    }
                }
            }
            
            checkRingDestruction() {
                // Check if ring boss touches any rings
                for (let i = 0; i < gameState.unlockedRings; i++) {
                    const ring = saturn.rings[i];
                    const dist = Math.sqrt((this.x - saturn.x) ** 2 + (this.y - saturn.y) ** 2);
                    
                    if (dist >= ring.inner - this.props.size && dist <= ring.outer + this.props.size) {
                        // Ring boss is touching this ring - destroy it
                        this.destroyRing(i);
                        break;
                    }
                }
            }
            
            destroyRing(ringIndex) {
                // Remove all defenders on this ring
                for (let i = gameState.defenders.length - 1; i >= 0; i--) {
                    if (gameState.defenders[i].ring === ringIndex) {
                        gameState.defenders.splice(i, 1);
                        gameState.totalDefendersPlaced--;
                    }
                }
                
                // Lock the ring (reduce unlocked rings)
                if (gameState.unlockedRings > 1) {
                    gameState.unlockedRings--;
                    document.getElementById('unlockedRings').textContent = gameState.unlockedRings;
                    
                    // Re-enable unlock button if needed
                    if (gameState.unlockedRings < 4) {
                        document.getElementById('unlockRingButton').style.background = '#660066';
                        document.getElementById('unlockRingButton').style.borderColor = '#880088';
                        document.getElementById('unlockRingButton').style.cursor = 'pointer';
                        document.getElementById('unlockRingButton').innerHTML = 'Unlock Ring<br>$500';
                    }
                }
                
                console.log('Ring', ringIndex, 'destroyed by ring boss!');
            }
            
            takeDamage(damage) {
                this.health -= damage;
                return this.health <= 0;
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                if (this.props.isRingBoss) {
                    // Draw ring boss with special effects
                    const pulse = Math.sin(Date.now() * 0.01) * 0.3 + 0.7;
                    ctx.fillStyle = this.props.color;
                    ctx.globalAlpha = pulse;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.props.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                    
                    // Draw boss aura
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.props.size + 5, 0, Math.PI * 2);
                    ctx.stroke();
                } else if (this.props.isJetpack) {
                    // Draw jetpack enemy with jetpack effects
                    ctx.fillStyle = this.props.color;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.props.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw jetpack
                    ctx.fillStyle = '#444444';
                    ctx.fillRect(-this.props.size * 0.8, -this.props.size * 0.3, this.props.size * 1.6, this.props.size * 0.6);
                    
                    // Draw jetpack flames
                    const flameSize = Math.sin(Date.now() * 0.02) * 3 + 8;
                    ctx.fillStyle = '#ff6600';
                    ctx.beginPath();
                    ctx.moveTo(-this.props.size * 0.6, this.props.size * 0.3);
                    ctx.lineTo(-this.props.size * 0.8, this.props.size * 0.3 + flameSize);
                    ctx.lineTo(-this.props.size * 0.4, this.props.size * 0.3);
                    ctx.fill();
                    
                    ctx.fillStyle = '#ffaa00';
                    ctx.beginPath();
                    ctx.moveTo(this.props.size * 0.6, this.props.size * 0.3);
                    ctx.lineTo(this.props.size * 0.8, this.props.size * 0.3 + flameSize);
                    ctx.lineTo(this.props.size * 0.4, this.props.size * 0.3);
                    ctx.fill();
                    
                    // Draw swoop trail
                    ctx.strokeStyle = 'rgba(255, 170, 68, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, -20);
                    ctx.stroke();
                } else {
                    // Draw normal enemy
                    ctx.fillStyle = this.props.color;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.props.size, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Draw health bar
                if (this.health < this.maxHealth) {
                    const barWidth = this.props.size * 2;
                    const barHeight = 3;
                    const healthPercent = this.health / this.maxHealth;
                    
                    ctx.fillStyle = '#333';
                    ctx.fillRect(-barWidth/2, -this.props.size - 8, barWidth, barHeight);
                    
                    ctx.fillStyle = healthPercent > 0.5 ? '#44ff44' : healthPercent > 0.25 ? '#ffff44' : '#ff4444';
                    ctx.fillRect(-barWidth/2, -this.props.size - 8, barWidth * healthPercent, barHeight);
                }
                
                ctx.restore();
            }
        }
        
        function getRingFromDistance(distance) {
            for (let i = 0; i < gameState.unlockedRings; i++) {
                const ring = saturn.rings[i];
                // Add some tolerance to ring detection
                if (distance >= ring.inner - 2 && distance <= ring.outer + 2) {
                    return i;
                }
            }
            return -1; // Not on any unlocked ring
        }
        
        function getDefenderAtPosition(x, y) {
            for (let i = gameState.defenders.length - 1; i >= 0; i--) {
                const defender = gameState.defenders[i];
                const dist = Math.sqrt((x - defender.x) ** 2 + (y - defender.y) ** 2);
                if (dist < defender.props.size + 5) {
                    return i;
                }
            }
            return -1;
        }
        
        function drawSaturn() {
            // Draw Saturn
            const gradient = ctx.createRadialGradient(saturn.x, saturn.y, 0, saturn.x, saturn.y, saturn.radius);
            gradient.addColorStop(0, '#ffddaa');
            gradient.addColorStop(0.7, '#ddaa77');
            gradient.addColorStop(1, '#aa7744');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(saturn.x, saturn.y, saturn.radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw only unlocked rings
            ctx.lineWidth = 2;
            for (let ringIndex = 0; ringIndex < gameState.unlockedRings; ringIndex++) {
                const ring = saturn.rings[ringIndex];
                ctx.strokeStyle = ring.color;
                
                for (let r = ring.inner; r <= ring.outer; r += 5) {
                    ctx.beginPath();
                    ctx.arc(saturn.x, saturn.y, r, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
            
            // Draw collision debug circles for all defenders
            if (gameState.selectedDefenseType && !gameState.deleteMode) {
                drawCollisionDebug();
            }
            
            // Draw gun on Saturn
            drawGun();
        }
        
        function drawCollisionDebug() {
            // Draw collision areas for all defenders
            for (const defender of gameState.defenders) {
                // Use current position instead of calculated position
                const x = defender.x;
                const y = defender.y;
                
                // Draw collision circle (8 degree radius) - more transparent
                ctx.strokeStyle = 'rgba(255, 0, 0, 0.2)';
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.arc(x, y, defender.orbitRadius * Math.sin(8 * Math.PI / 180), 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Draw defender position - more transparent
                ctx.fillStyle = 'rgba(255, 0, 0, 0.1)';
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        function drawGun() {
            // Only calculate target angle and rotate when gun is active
            if (gameState.gunActive) {
                // Calculate target angle based on mouse position
                const dx = gameState.mouseX - saturn.x;
                const dy = gameState.mouseY - saturn.y;
                gameState.targetGunAngle = Math.atan2(dy, dx);
                
                // Smooth rotation towards target angle
                let angleDiff = gameState.targetGunAngle - gameState.gunAngle;
                if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                
                gameState.gunAngle += angleDiff * gunConfig.rotationSpeed;
                
                // Animate barrel extension
                gameState.barrelExtension = Math.min(1, gameState.barrelExtension + 0.1);
            } else {
                // Animate barrel retraction
                gameState.barrelExtension = Math.max(0, gameState.barrelExtension - 0.1);
            }
            
            ctx.save();
            ctx.translate(saturn.x, saturn.y);
            ctx.rotate(gameState.gunAngle);
            
            // Draw cannon base (circular platform) - always grey
            const baseGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, gunConfig.baseSize);
            baseGradient.addColorStop(0, '#888888');
            baseGradient.addColorStop(0.7, '#666666');
            baseGradient.addColorStop(1, '#444444');
            
            ctx.fillStyle = baseGradient;
            ctx.beginPath();
            ctx.arc(0, 0, gunConfig.baseSize, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw base border - always grey
            ctx.strokeStyle = '#aaaaaa';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, gunConfig.baseSize, 0, Math.PI * 2);
            ctx.stroke();
            
            // Draw cannon barrel only when extended
            if (gameState.barrelExtension > 0) {
                const barrelLength = gunConfig.barrelLength * gameState.barrelExtension;
                
                // Draw cannon barrel - always grey
                const barrelGradient = ctx.createLinearGradient(0, -gunConfig.barrelWidth/2, barrelLength, -gunConfig.barrelWidth/2);
                barrelGradient.addColorStop(0, '#666666');
                barrelGradient.addColorStop(0.5, '#888888');
                barrelGradient.addColorStop(1, '#aaaaaa');
                
                ctx.fillStyle = barrelGradient;
                ctx.fillRect(0, -gunConfig.barrelWidth/2, barrelLength, gunConfig.barrelWidth);
                
                // Draw barrel border - always grey
                ctx.strokeStyle = '#cccccc';
                ctx.lineWidth = 1;
                ctx.strokeRect(0, -gunConfig.barrelWidth/2, barrelLength, gunConfig.barrelWidth);
                
                // Draw barrel details - always grey
                ctx.strokeStyle = '#dddddd';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(5, -gunConfig.barrelWidth/2 + 2);
                ctx.lineTo(5, gunConfig.barrelWidth/2 - 2);
                ctx.moveTo(15, -gunConfig.barrelWidth/2 + 2);
                ctx.lineTo(15, gunConfig.barrelWidth/2 - 2);
                ctx.stroke();
            }
            
            // Draw targeting reticle on base - always grey
            ctx.strokeStyle = '#888888';
            ctx.lineWidth = 1;
            ctx.setLineDash([2, 2]);
            ctx.beginPath();
            ctx.arc(0, 0, gunConfig.baseSize - 5, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw status indicator - bigger and green when active, red when inactive
            ctx.fillStyle = gameState.gunActive ? '#00ff00' : '#ff0000';
            ctx.beginPath();
            ctx.arc(0, 0, 4, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
            
            // Draw gun status text
            ctx.fillStyle = 'white';
            ctx.font = '10px Courier New';
            ctx.textAlign = 'center';
        }
        
        function drawAimRing(mouseX, mouseY) {
            if (!gameState.gunActive) return;
            
            // Draw aiming ring
            ctx.strokeStyle = gunConfig.aimRingColor;
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.arc(mouseX, mouseY, gunConfig.aimRingRadius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw crosshair
            ctx.strokeStyle = gunConfig.aimRingColor;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(mouseX - 10, mouseY);
            ctx.lineTo(mouseX + 10, mouseY);
            ctx.moveTo(mouseX, mouseY - 10);
            ctx.lineTo(mouseX, mouseY + 10);
            ctx.stroke();
        }
        
        function fireGun(targetX, targetY) {
            if (!gameState.gunActive || gameState.gunCooldown > 0 || gameState.money < gunConfig.cost) return;
            
            // Deduct cost
            gameState.money -= gunConfig.cost;
            gameState.gunCooldown = gunConfig.cooldown;
            
            // Calculate firing position from barrel tip (using animated length)
            const barrelLength = gunConfig.barrelLength * gameState.barrelExtension;
            const barrelTipX = saturn.x + Math.cos(gameState.gunAngle) * barrelLength;
            const barrelTipY = saturn.y + Math.sin(gameState.gunAngle) * barrelLength;
            
            // Calculate direction from barrel tip to target
            const dx = targetX - barrelTipX;
            const dy = targetY - barrelTipY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            // Create laser projectile
            const laser = {
                x: barrelTipX,
                y: barrelTipY,
                targetX: targetX,
                targetY: targetY,
                damage: gunConfig.damage,
                range: gunConfig.range,
                width: gunConfig.width,
                color: gunConfig.color,
                life: 1000,
                isLaser: true
            };
            
            // Calculate velocity
            laser.vx = (dx / dist) * 15; // Fast laser speed
            laser.vy = (dy / dist) * 15;
            
            gameState.projectiles.push(laser);
            
            // Create muzzle flash effect at barrel tip
            createMuzzleFlash(barrelTipX, barrelTipY, dx / dist, dy / dist);
            
            console.log('Laser cannon fired! Cost: $' + gunConfig.cost + ', Damage: ' + gunConfig.damage);
        }
        
        function createMuzzleFlash(x, y, dirX, dirY) {
            // Create muzzle flash particles
            for (let i = 0; i < 5; i++) {
                gameState.particles.push({
                    x: x + dirX * 20,
                    y: y + dirY * 20,
                    vx: (Math.random() - 0.5) * 3 + dirX * 2,
                    vy: (Math.random() - 0.5) * 3 + dirY * 2,
                    color: '#ffff00',
                    life: 15,
                    maxLife: 15
                });
            }
        }
        
        function updateProjectiles(deltaTime) {
            for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
                const proj = gameState.projectiles[i];
                
                proj.x += proj.vx * deltaTime / 16;
                proj.y += proj.vy * deltaTime / 16;
                proj.life -= deltaTime;
                
                // Check collision with enemies
                let hit = false;
                for (let j = gameState.enemies.length - 1; j >= 0; j--) {
                    const enemy = gameState.enemies[j];
                    const dist = Math.sqrt((enemy.x - proj.x) ** 2 + (enemy.y - proj.y) ** 2);
                    
                    if (dist < enemy.props.size + (proj.isLaser ? proj.width : 5)) {
                        // Hit!
                        if (proj.type === 'shield') {
                            enemy.slow = 0.3; // Slow effect
                        }
                        
                        if (enemy.takeDamage(proj.damage)) {
                            // Enemy killed - apply kill multiplier to rewards
                            gameState.totalEnemiesKilled++;
                            updateMultipliers(); // Update multipliers first
                            
                            const reward = Math.floor(enemy.reward * gameState.killMultiplier);
                            gameState.money += reward;
                            gameState.score += reward * 10;
                            gameState.enemiesKilled++;
                            gameState.enemies.splice(j, 1);
                            
                            // Create explosion particles
                            createExplosion(enemy.x, enemy.y, enemy.props.color);
                            
                            console.log('Enemy killed! Total kills:', gameState.totalEnemiesKilled, 'Multiplier:', gameState.killMultiplier);
                        }
                        
                        if (proj.type === 'missile') {
                            // Explosive damage to nearby enemies
                            for (let k = gameState.enemies.length - 1; k >= 0; k--) {
                                const nearbyEnemy = gameState.enemies[k];
                                if (nearbyEnemy !== enemy) { // Don't double-hit the main target
                                    const explosionDist = Math.sqrt((nearbyEnemy.x - proj.x) ** 2 + (nearbyEnemy.y - proj.y) ** 2);
                                    if (explosionDist < 50) {
                                        if (nearbyEnemy.takeDamage(proj.damage * 0.5)) {
                                            // Nearby enemy also killed by explosion
                                            gameState.totalEnemiesKilled++;
                                            updateMultipliers();
                                            
                                            const reward = Math.floor(nearbyEnemy.reward * gameState.killMultiplier);
                                            gameState.money += reward;
                                            gameState.score += reward * 10;
                                            gameState.enemiesKilled++;
                                            gameState.enemies.splice(k, 1);
                                            
                                            createExplosion(nearbyEnemy.x, nearbyEnemy.y, nearbyEnemy.props.color);
                                            console.log('Explosion kill! Total kills:', gameState.totalEnemiesKilled);
                                        }
                                    }
                                }
                            }
                            createExplosion(proj.x, proj.y, '#ffaa44');
                        }
                        
                        if (proj.type !== 'plasma' && !proj.isLaser) { // Plasma and lasers pierce
                            hit = true;
                            break;
                        }
                    }
                }
                
                if (hit || proj.life <= 0) {
                    gameState.projectiles.splice(i, 1);
                }
            }
        }
        
        function createExplosion(x, y, color) {
            for (let i = 0; i < 8; i++) {
                gameState.particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    color: color,
                    life: 30,
                    maxLife: 30
                });
            }
        }
        
        function createStars() {
            // Create 100 stars for the background
            for (let i = 0; i < 100; i++) {
                gameState.stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 2 + 0.5,
                    brightness: Math.random() * 0.8 + 0.2,
                    twinkle: Math.random() * Math.PI * 2
                });
            }
        }
        
        function drawStars() {
            for (const star of gameState.stars) {
                // Twinkling effect
                const twinkle = Math.sin(Date.now() * 0.001 + star.twinkle) * 0.3 + 0.7;
                const alpha = star.brightness * twinkle;
                
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        function updateParticles(deltaTime) {
            for (let i = gameState.particles.length - 1; i >= 0; i--) {
                const particle = gameState.particles[i];
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life--;
                
                if (particle.life <= 0) {
                    gameState.particles.splice(i, 1);
                }
            }
        }
        
        function drawProjectiles() {
            for (const proj of gameState.projectiles) {
                if (proj.isLaser) {
                    // Draw laser with special effects
                    const gradient = ctx.createLinearGradient(proj.x, proj.y, proj.x - proj.vx * 2, proj.y - proj.vy * 2);
                    gradient.addColorStop(0, proj.color);
                    gradient.addColorStop(0.5, '#ffffff');
                    gradient.addColorStop(1, proj.color);
                    
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = proj.width;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(proj.x, proj.y);
                    ctx.lineTo(proj.x - proj.vx * 2, proj.y - proj.vy * 2);
                    ctx.stroke();
                    
                    // Draw laser glow
                    ctx.strokeStyle = proj.color;
                    ctx.globalAlpha = 0.3;
                    ctx.lineWidth = proj.width * 2;
                    ctx.beginPath();
                    ctx.moveTo(proj.x, proj.y);
                    ctx.lineTo(proj.x - proj.vx * 2, proj.y - proj.vy * 2);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                } else {
                    // Draw normal projectiles
                    ctx.fillStyle = proj.color;
                    ctx.beginPath();
                    ctx.arc(proj.x, proj.y, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    if (proj.type === 'laser') {
                        ctx.strokeStyle = proj.color;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(proj.x - proj.vx, proj.y - proj.vy);
                        ctx.lineTo(proj.x, proj.y);
                        ctx.stroke();
                    }
                }
            }
        }
        
        function drawParticles() {
            for (const particle of gameState.particles) {
                const alpha = particle.life / particle.maxLife;
                ctx.fillStyle = particle.color.replace(')', `, ${alpha})`).replace('rgb', 'rgba');
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        function spawnWave() {
            if (gameState.waveActive || !gameState.gameRunning) return;
            
            console.log('Spawning wave', gameState.wave);
            gameState.waveActive = true;
            gameState.enemiesSpawned = 0;
            gameState.enemiesKilled = 0;
            gameState.waveStartTime = Date.now();
            
            // Exponentially increasing enemy count: 5 * (1.3 ^ wave)
            const waveSize = Math.min(Math.floor(5 * Math.pow(1.3, gameState.wave)), 100);
            // Exponentially faster spawning: starts at 800ms, decreases by 10% each wave
            const baseSpawnInterval = 800;
            const spawnInterval = Math.max(50, Math.floor(baseSpawnInterval / Math.pow(1.1, gameState.wave)));
            
            console.log('Wave size:', waveSize, 'Spawn interval:', spawnInterval);
            
            function spawnEnemy() {
                if (gameState.enemiesSpawned >= waveSize || !gameState.gameRunning) return;
                
                let enemyType = 'basic';
                const rand = Math.random();
                
                if (gameState.wave >= 3 && rand < 0.3) enemyType = 'fast';
                if (gameState.wave >= 5 && rand < 0.2) enemyType = 'heavy';
                if (gameState.wave >= 7 && rand < 0.15) enemyType = 'jetpack'; // Add jetpack enemies
                if (gameState.wave >= 10 && rand < 0.1) enemyType = 'boss';
                
                const enemy = new Enemy(enemyType);
                gameState.enemies.push(enemy);
                gameState.enemiesSpawned++;
                
                console.log('Spawned enemy', gameState.enemiesSpawned, 'of', waveSize, 'at position', enemy.x, enemy.y);
                
                if (gameState.enemiesSpawned < waveSize) {
                    setTimeout(spawnEnemy, spawnInterval);
                }
            }
            
            spawnEnemy();
            
            // Spawn ring boss every 5 waves
            if (gameState.wave % 5 === 0) {
                gameState.ringBossWaves++; // Increment ring boss wave counter
                document.getElementById('bossWarning').style.display = 'block';
                setTimeout(() => {
                    if (gameState.gameRunning) {
                        const ringBoss = new Enemy('ringBoss');
                        gameState.enemies.push(ringBoss);
                        console.log('Ring boss spawned! Wave:', gameState.ringBossWaves, 'Health:', ringBoss.health, 'Speed multiplier:', 1 + gameState.ringBossWaves * 0.2);
                    }
                }, 2000);
            } else {
                document.getElementById('bossWarning').style.display = 'none';
            }
        }
        
        function checkWaveComplete() {
            if (gameState.waveActive && gameState.enemies.length === 0 && gameState.enemiesSpawned > 0) {
                gameState.waveActive = false;
                gameState.wave++;
                gameState.money += 50; // Wave completion bonus
                
                // Reduce delay between waves as game progresses
                const waveDelay = Math.max(1000, 3000 - gameState.wave * 100);
                console.log('Wave completed! Starting wave', gameState.wave, 'in', waveDelay, 'ms');
                setTimeout(() => spawnWave(), waveDelay);
            }
        }
        
        function updateMultipliers() {
            // Kill multiplier thresholds
            if (gameState.totalEnemiesKilled >= 200) {
                gameState.killMultiplier = 2.0;
            } else if (gameState.totalEnemiesKilled >= 100) {
                gameState.killMultiplier = 1.7;
            } else if (gameState.totalEnemiesKilled >= 50) {
                gameState.killMultiplier = 1.5;
            } else if (gameState.totalEnemiesKilled >= 25) {
                gameState.killMultiplier = 1.3;
            } else if (gameState.totalEnemiesKilled >= 10) {
                gameState.killMultiplier = 1.2;
            } else {
                gameState.killMultiplier = 1.0;
            }
            
            // Defender damage bonus (5% per defender)
            gameState.defenderBonus = gameState.totalDefendersPlaced * 5;
        }
        
        function gameLoop(timestamp) {
            if (gameState.gamePaused) {
                // When paused, only draw the current state without updating
                // Clear canvas
                ctx.fillStyle = 'rgba(0, 0, 17, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw stars first (background)
                drawStars();
                
                // Draw Saturn and rings
                drawSaturn();
                
                // Draw defenders (without updating)
                for (const defender of gameState.defenders) {
                    defender.draw();
                }
                
                // Draw enemies (without updating)
                for (const enemy of gameState.enemies) {
                    enemy.draw();
                }
                
                // Draw projectiles and particles (without updating)
                drawProjectiles();
                drawParticles();
                
                // Draw aim ring if gun is active
                drawAimRing(gameState.mouseX, gameState.mouseY);
                
                // Update UI every frame
                document.getElementById('money').textContent = gameState.money;
                document.getElementById('lives').textContent = gameState.lives;
                document.getElementById('score').textContent = gameState.score;
                document.getElementById('wave').textContent = gameState.wave;
                document.getElementById('enemiesLeft').textContent = gameState.enemies.length;
                document.getElementById('totalKills').textContent = gameState.totalEnemiesKilled;
                document.getElementById('killMultiplier').textContent = gameState.killMultiplier.toFixed(1);
                document.getElementById('totalDefenders').textContent = gameState.totalDefendersPlaced;
                document.getElementById('defenderBonus').textContent = gameState.defenderBonus;
                document.getElementById('unlockedRings').textContent = gameState.unlockedRings;
                
                requestAnimationFrame(gameLoop);
                return;
            }
            
            // Only update lastUpdate when not paused to prevent huge deltaTime
            const deltaTime = timestamp - gameState.lastUpdate;
            gameState.lastUpdate = timestamp;
            
            // Update gun cooldown
            if (gameState.gunCooldown > 0) {
                gameState.gunCooldown -= deltaTime;
            }
            
            // Clear canvas
            ctx.fillStyle = 'rgba(0, 0, 17, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw stars first (background)
            drawStars();
            
            // Draw Saturn and rings
            drawSaturn();
            
            // Update and draw defenders
            for (const defender of gameState.defenders) {
                defender.update(deltaTime);
                defender.draw();
            }
            
            // Update and draw enemies
            for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                if (!gameState.enemies[i].update(deltaTime)) {
                    gameState.enemies.splice(i, 1);
                }
            }
            
            for (const enemy of gameState.enemies) {
                enemy.draw();
            }
            
            // Update projectiles and particles
            updateProjectiles(deltaTime);
            updateParticles(deltaTime);
            
            // Draw projectiles and particles
            drawProjectiles();
            drawParticles();
            
            // Draw aim ring if gun is active
            drawAimRing(gameState.mouseX, gameState.mouseY);
            
            // Check wave completion
            checkWaveComplete();
            
            // Update UI every frame
            if (gameState.gameRunning) {
                document.getElementById('money').textContent = gameState.money;
                document.getElementById('lives').textContent = gameState.lives;
                document.getElementById('score').textContent = gameState.score;
                document.getElementById('wave').textContent = gameState.wave;
                document.getElementById('enemiesLeft').textContent = gameState.enemies.length;
                document.getElementById('totalKills').textContent = gameState.totalEnemiesKilled;
                document.getElementById('killMultiplier').textContent = gameState.killMultiplier.toFixed(1);
                document.getElementById('totalDefenders').textContent = gameState.totalDefendersPlaced;
                document.getElementById('defenderBonus').textContent = gameState.defenderBonus;
                document.getElementById('unlockedRings').textContent = gameState.unlockedRings;
            }
            
            // Game over check
            if (gameState.lives <= 0 && !gameState.gameOver) {
                gameState.gameOver = true;
                gameState.gameRunning = false;
                gameState.gameStarted = false;
                
                // Show restart button on game over
                document.getElementById('startButton').style.display = 'block';
                document.getElementById('startButton').textContent = 'RESTART GAME';
                document.getElementById('pauseButton').style.display = 'none';
            }
            
            // Draw game over screen if game is over
            if (gameState.gameOver) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'white';
                ctx.font = '48px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2);
                ctx.font = '24px Courier New';
                ctx.fillText(`Final Score: ${gameState.score}`, canvas.width/2, canvas.height/2 + 60);
                requestAnimationFrame(gameLoop);
                return;
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        // Event listeners
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            let x = e.clientX - rect.left;
            let y = e.clientY - rect.top;
            
            // Adjust coordinates for mobile scaling
            const scale = window.innerWidth <= 768 ? (window.innerWidth <= 480 ? (window.innerWidth <= 360 ? 0.65 : 0.75) : 0.85) : 1;
            if (scale !== 1) {
                // Calculate the scaled canvas size
                const scaledWidth = canvas.width * scale;
                const scaledHeight = canvas.height * scale;
                
                // Calculate the offset to center the scaled canvas
                const offsetX = (rect.width - scaledWidth) / 2;
                const offsetY = (rect.height - scaledHeight) / 2;
                
                // Adjust click coordinates for scaling
                x = (x - offsetX) / scale;
                y = (y - offsetY) / scale;
            }
            
            // Allow clicks when game is over (for restart button)
            if (gameState.gameOver) {
                return; // Let the restart button handle the click
            }
            
            if (!gameState.gameRunning || gameState.gamePaused) return;
            
            // Check if clicking on the gun (Saturn center)
            const distFromSaturn = Math.sqrt((x - saturn.x) ** 2 + (y - saturn.y) ** 2);
            if (distFromSaturn < gunConfig.baseSize + 5) {
                // Toggle gun on/off
                gameState.gunActive = !gameState.gunActive;
                gameState.selectedDefenseType = null; // Clear defense selection
                gameState.deleteMode = false; // Exit delete mode
                
                // Update UI
                document.querySelectorAll('.defenseButton').forEach(b => b.classList.remove('selected'));
                document.getElementById('deleteButton').style.background = '#660000';
                document.getElementById('deleteButton').style.borderColor = '#880000';
                document.getElementById('deleteButton').innerHTML = 'Delete Defender<br>50% Refund';
                
                console.log('Gun toggled:', gameState.gunActive ? 'ON' : 'OFF');
                return;
            }
            
            // If gun is active, fire it
            if (gameState.gunActive) {
                fireGun(x, y);
                return;
            }
            
            // Check if clicking on a defender (for deletion)
            if (gameState.deleteMode) {
                const defenderIndex = getDefenderAtPosition(x, y);
                if (defenderIndex !== -1) {
                    const defender = gameState.defenders[defenderIndex];
                    const refund = Math.floor(defenseTypes[defender.type].cost * 0.5);
                    gameState.money += refund;
                    gameState.totalDefendersPlaced--;
                    gameState.defenders.splice(defenderIndex, 1);
                    updateMultipliers();
                    console.log('Defender deleted! Refunded $' + refund);
                    return;
                }
            }
            
            // Normal placement mode
            if (!gameState.selectedDefenseType) return;
            
            console.log('Canvas clicked at', x, y, 'Selected type:', gameState.selectedDefenseType);
            
            // Check if click is on any of Saturn's rings
            const dist = Math.sqrt((x - saturn.x) ** 2 + (y - saturn.y) ** 2);
            const clickedRing = getRingFromDistance(dist);
            
            console.log('Distance from Saturn center:', dist, 'Clicked ring:', clickedRing);
            
            if (clickedRing !== -1) {
                const cost = defenseTypes[gameState.selectedDefenseType].cost;
                console.log('Clicked on ring', clickedRing, 'cost:', cost, 'money:', gameState.money);
                
                if (gameState.money >= cost) {
                    // Calculate angle
                    const angle = Math.atan2(y - saturn.y, x - saturn.x) * 180 / Math.PI;
                    
                    // Check if spot is free on the clicked ring
                    let canPlace = true;
                    
                    for (const defender of gameState.defenders) {
                        // Only check conflicts with defenders on the same ring
                        if (defender.ring === clickedRing) {
                            // Calculate current angle of the defender based on its current position
                            const currentDefenderAngle = Math.atan2(defender.y - saturn.y, defender.x - saturn.x) * 180 / Math.PI;
                            let angleDiff = Math.abs(currentDefenderAngle - angle);
                            if (angleDiff > 180) angleDiff = 360 - angleDiff; // Handle wrap-around
                            
                            if (angleDiff < 8) { // Reduced from 10 to 8 degrees for easier placement
                                canPlace = false;
                                break;
                            }
                        }
                    }
                    
                    if (canPlace) {
                        gameState.totalDefendersPlaced++;
                        updateMultipliers(); // Update defender bonus first
                        
                        const defender = new Defender(angle, gameState.selectedDefenseType, clickedRing);
                        gameState.defenders.push(defender);
                        gameState.money -= cost;
                    }
                } else {
                    console.log('Not enough money - need', cost, 'have', gameState.money);
                }
            } else {
                console.log('Clicked outside ring area');
            }
        });
        
        // Track mouse position for aim ring
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            let x = e.clientX - rect.left;
            let y = e.clientY - rect.top;
            
            // Adjust coordinates for mobile scaling
            const scale = window.innerWidth <= 768 ? (window.innerWidth <= 480 ? (window.innerWidth <= 360 ? 0.65 : 0.75) : 0.85) : 1;
            if (scale !== 1) {
                // Calculate the scaled canvas size
                const scaledWidth = canvas.width * scale;
                const scaledHeight = canvas.height * scale;
                
                // Calculate the offset to center the scaled canvas
                const offsetX = (rect.width - scaledWidth) / 2;
                const offsetY = (rect.height - scaledHeight) / 2;
                
                // Adjust mouse coordinates for scaling
                x = (x - offsetX) / scale;
                y = (y - offsetY) / scale;
            }
            
            gameState.mouseX = x;
            gameState.mouseY = y;
        });
        
        // Defense selection
        document.querySelectorAll('.defenseButton').forEach(button => {
            button.addEventListener('click', () => {
                const type = button.dataset.type;
                const cost = parseInt(button.dataset.cost);
                
                console.log('Defense button clicked:', type, 'cost:', cost, 'money:', gameState.money);
                
                if (gameState.money >= cost) {
                    gameState.selectedDefenseType = type;
                    gameState.deleteMode = false; // Exit delete mode
                    gameState.gunActive = false; // Deactivate gun
                    
                    // Update UI
                    document.querySelectorAll('.defenseButton').forEach(b => b.classList.remove('selected'));
                    button.classList.add('selected');
                    document.getElementById('deleteButton').style.background = '#660000';
                    document.getElementById('deleteButton').style.borderColor = '#880000';
                    document.getElementById('deleteButton').innerHTML = 'Delete Defender<br>50% Refund';
                    
                    console.log('Selected defense type:', type);
                } else {
                    button.classList.add('disabled');
                    setTimeout(() => button.classList.remove('disabled'), 500);
                }
            });
        });
        
        // Upgrade selection
        document.querySelectorAll('.upgradeButton').forEach(button => {
            button.addEventListener('click', () => {
                const type = button.dataset.type;
                const cost = parseInt(button.dataset.cost);
                
                console.log('Upgrade button clicked:', type, 'cost:', cost, 'money:', gameState.money);
                
                if (gameState.money >= cost) {
                    gameState.defenderUpgrades[type]++;
                    gameState.money -= cost;
                    gameState.gunActive = false; // Deactivate gun
                    
                    // Update button text to show new level
                    const level = gameState.defenderUpgrades[type];
                    const damageMultiplier = Math.pow(1.02, level).toFixed(2);
                    button.innerHTML = `Upgrade ${type.charAt(0).toUpperCase() + type.slice(1)}<br>Lv.${level} ${Math.trunc((damageMultiplier - 1)* 100)}%`;
                    
                    console.log('Upgraded', type, 'to level', level, 'damage multiplier:', damageMultiplier);
                } else {
                    button.classList.add('disabled');
                    setTimeout(() => button.classList.remove('disabled'), 500);
                }
            });
        });
        
        // Ring unlock button
        document.getElementById('unlockRingButton').addEventListener('click', () => {
            if (gameState.unlockedRings < 4 && gameState.money >= 500) {
                gameState.unlockedRings++;
                gameState.money -= 500;
                gameState.gunActive = false; // Deactivate gun
                document.getElementById('unlockedRings').textContent = gameState.unlockedRings;
                console.log('Unlocked ring', gameState.unlockedRings);
                
                // Disable button if max rings reached
                if (gameState.unlockedRings >= 4) {
                    document.getElementById('unlockRingButton').style.background = '#333';
                    document.getElementById('unlockRingButton').style.borderColor = '#555';
                    document.getElementById('unlockRingButton').style.cursor = 'not-allowed';
                    document.getElementById('unlockRingButton').textContent = 'All Rings Unlocked';
                }
            } else if (gameState.unlockedRings >= 4) {
                console.log('All rings already unlocked');
            } else {
                console.log('Not enough money to unlock ring');
                document.getElementById('unlockRingButton').style.background = '#660000';
                document.getElementById('unlockRingButton').style.borderColor = '#880000';
                setTimeout(() => {
                    document.getElementById('unlockRingButton').style.background = '#660066';
                    document.getElementById('unlockRingButton').style.borderColor = '#880088';
                }, 500);
            }
        });
        
        // Delete button
        document.getElementById('deleteButton').addEventListener('click', () => {
            gameState.deleteMode = !gameState.deleteMode;
            gameState.selectedDefenseType = null; // Clear defense selection
            gameState.gunActive = false; // Deactivate gun
            
            // Update UI
            document.querySelectorAll('.defenseButton').forEach(b => b.classList.remove('selected'));
            
            if (gameState.deleteMode) {
                document.getElementById('deleteButton').style.background = '#ff0000';
                document.getElementById('deleteButton').style.borderColor = '#ff4444';
                document.getElementById('deleteButton').textContent = 'Click Defenders to Delete';
            } else {
                document.getElementById('deleteButton').style.background = '#660000';
                document.getElementById('deleteButton').style.borderColor = '#880000';
                document.getElementById('deleteButton').innerHTML = 'Delete Defender<br>50% Refund';
            }
            
            console.log('Delete mode:', gameState.deleteMode ? 'ON' : 'OFF');
        });
        
        // Start button
        document.getElementById('startButton').addEventListener('click', () => {
            if (!gameState.gameStarted || gameState.gameOver) {
                // Reset game state for new game
                gameState = {
                    money: 100,
                    lives: 20,
                    score: 0,
                    wave: 1,
                    selectedDefenseType: null,
                    unlockedRings: 1,
                    deleteMode: false,
                    defenders: [],
                    enemies: [],
                    projectiles: [],
                    particles: [],
                    stars: [], // Clear stars
                    lastUpdate: 0,
                    waveActive: false,
                    enemiesSpawned: 0,
                    enemiesKilled: 0,
                    totalEnemiesKilled: 0,
                    totalDefendersPlaced: 0,
                    waveStartTime: 0,
                    nextWaveDelay: 3000,
                    gameStarted: true,
                    gameRunning: true,
                    gamePaused: false,
                    gameOver: false, // Reset game over state
                    killMultiplier: 1,
                    defenderBonus: 1,
                    ringBossWaves: 0, // Reset ring boss waves
                    defenderUpgrades: { laser: 0, missile: 0, plasma: 0, shield: 0 }, // Reset upgrade levels
                    gunActive: false, // Reset gun state
                    gunCooldown: 0, // Reset gun cooldown
                    mouseX: canvas.width / 2, // Reset mouse position to center
                    mouseY: canvas.height / 2, // Reset mouse position to center
                    gunAngle: 0, // Reset gun rotation angle
                    targetGunAngle: 0, // Reset target angle
                    barrelExtension: 0 // Reset barrel slide animation (0-1)
                };
                
                // Reset UI
                document.getElementById('startButton').style.display = 'none';
                document.getElementById('startButton').textContent = 'START GAME';
                document.getElementById('pauseButton').style.display = 'block';
                document.getElementById('bossWarning').style.display = 'none';
                document.querySelectorAll('.defenseButton').forEach(b => b.classList.remove('selected'));
                document.getElementById('unlockedRings').textContent = '1';
                document.getElementById('unlockRingButton').style.background = '#660066';
                document.getElementById('unlockRingButton').style.borderColor = '#880088';
                document.getElementById('unlockRingButton').style.cursor = 'pointer';
                document.getElementById('unlockRingButton').innerHTML = 'Unlock Ring<br>$500';
                document.getElementById('deleteButton').style.background = '#660000';
                document.getElementById('deleteButton').style.borderColor = '#880000';
                document.getElementById('deleteButton').innerHTML = 'Delete Defender<br>50% Refund';
                
                // Reset upgrade buttons
                document.querySelectorAll('.upgradeButton').forEach(button => {
                    const type = button.dataset.type;
                    button.innerHTML = `Upgrade<br>$100`;
                });
                
                // Initialize stars
                createStars();
                
                console.log('Game started/restarted!');
                
                // Automatically start the game after a short delay
                setTimeout(() => {
                    spawnWave();
                }, 2000);
            }
        });
        
        // Pause button
        document.getElementById('pauseButton').addEventListener('click', () => {
            gameState.gamePaused = true;
            gameState.pauseStartTime = performance.now();
            document.getElementById('pauseMenu').style.display = 'block';
        });
        
        // Resume button
        document.getElementById('resumeButton').addEventListener('click', () => {
            gameState.gamePaused = false;
            // Adjust lastUpdate to account for pause time
            const pauseDuration = performance.now() - gameState.pauseStartTime;
            gameState.lastUpdate += pauseDuration;
            document.getElementById('pauseMenu').style.display = 'none';
        });
        
        // Restart button
        document.getElementById('restartButton').addEventListener('click', () => {
            // Reset all game state
            gameState = {
                money: 100,
                lives: 20,
                score: 0,
                wave: 1,
                selectedDefenseType: null,
                unlockedRings: 1,
                deleteMode: false,
                defenders: [],
                enemies: [],
                projectiles: [],
                particles: [],
                stars: [], // Clear stars
                lastUpdate: 0,
                waveActive: false,
                enemiesSpawned: 0,
                enemiesKilled: 0,
                totalEnemiesKilled: 0,
                totalDefendersPlaced: 0,
                waveStartTime: 0,
                nextWaveDelay: 3000,
                gameStarted: true,
                gameRunning: true,
                gamePaused: false,
                gameOver: false, // Reset game over state
                killMultiplier: 1,
                defenderBonus: 1,
                ringBossWaves: 0, // Reset ring boss waves
                defenderUpgrades: { laser: 0, missile: 0, plasma: 0, shield: 0 }, // Reset upgrade levels
                gunActive: false, // Reset gun state
                gunCooldown: 0, // Reset gun cooldown
                mouseX: canvas.width / 2, // Reset mouse position to center
                mouseY: canvas.height / 2, // Reset mouse position to center
                gunAngle: 0, // Reset gun rotation angle
                targetGunAngle: 0, // Reset target angle
                barrelExtension: 0 // Reset barrel slide animation (0-1)
            };
            
            // Reset UI
            document.getElementById('pauseMenu').style.display = 'none';
            document.getElementById('startButton').style.display = 'none';
            document.getElementById('startButton').textContent = 'START GAME';
            document.getElementById('pauseButton').style.display = 'block';
            document.getElementById('bossWarning').style.display = 'none';
            document.querySelectorAll('.defenseButton').forEach(b => b.classList.remove('selected'));
            document.getElementById('unlockedRings').textContent = '1';
            document.getElementById('unlockRingButton').style.background = '#660066';
            document.getElementById('unlockRingButton').style.borderColor = '#880088';
            document.getElementById('unlockRingButton').style.cursor = 'pointer';
            document.getElementById('unlockRingButton').innerHTML = 'Unlock Ring<br>$500';
            document.getElementById('deleteButton').style.background = '#660000';
            document.getElementById('deleteButton').style.borderColor = '#880000';
            document.getElementById('deleteButton').innerHTML = 'Delete Defender<br>50% Refund';
            
            // Reset upgrade buttons
            document.querySelectorAll('.upgradeButton').forEach(button => {
                const type = button.dataset.type;
                button.innerHTML = `Upgrade<br>$100`;
            });
            
            // Initialize stars
            createStars();
            
            console.log('Game restarted from pause menu!');
            
            // Automatically start the game after a short delay
            setTimeout(() => {
                spawnWave();
            }, 2000);
        });
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === ' ' || e.key === 'Escape') {
                e.preventDefault();
                if (gameState.gameRunning && !gameState.gamePaused) {
                    gameState.gamePaused = true;
                    gameState.pauseStartTime = performance.now();
                    document.getElementById('pauseMenu').style.display = 'block';
                } else if (gameState.gamePaused) {
                    gameState.gamePaused = false;
                    // Adjust lastUpdate to account for pause time
                    const pauseDuration = performance.now() - gameState.pauseStartTime;
                    gameState.lastUpdate += pauseDuration;
                    document.getElementById('pauseMenu').style.display = 'none';
                }
            }
        });
        
        // Update button states
        setInterval(() => {
            document.querySelectorAll('.defenseButton').forEach(button => {
                const cost = parseInt(button.dataset.cost);
                if (gameState.money >= cost) {
                    button.classList.remove('disabled');
                } else {
                    button.classList.add('disabled');
                }
            });
            
            document.querySelectorAll('.upgradeButton').forEach(button => {
                const cost = parseInt(button.dataset.cost);
                if (gameState.money >= cost) {
                    button.classList.remove('disabled');
                } else {
                    button.classList.add('disabled');
                }
            });
        }, 100);
        
        // Money generation (like Battle Cats)
        setInterval(() => {
            if (gameState.gameRunning) {
                gameState.money += 2;
            }
        }, 1000);
        
        // Start the game loop
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>